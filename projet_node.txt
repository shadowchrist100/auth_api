//schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
}

// Modèle Utilisateur
model User {
  id                 String    @id @default(uuid())
  email              String    @unique
  password           String?   // Optionnel pour l'OAuth futur 
  firstName          String?
  lastName           String?
  emailVerifiedAt    DateTime? // null = non vérifié 
  emailVerifyToken   String?
  expiresAt          DateTime?
  twoFactorSecret    String?
  twoFactorEnabledAt DateTime?
  disabledAt         DateTime? // null = actif 
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  oauthAccounts   OAuthAccount[]
  refreshTokens   RefreshToken[]
  resetTokens     PasswordResetToken[]
  verificationTokens VerificationToken[]
  loginHistories  LoginHistory[]
}

model OAuthAccount {
  id         String   @id @default(uuid())
  provider   String
  providerId String
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([provider, providerId]) 
}

model RefreshToken {
  id        String    @id @default(uuid())
  token     String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userAgent String?
  ipAddress String?
  expiresAt DateTime
  revokedAt DateTime? // null = actif 
  createdAt DateTime  @default(now())
}

model BlacklistedAccessToken {
  id        String   @id @default(uuid())
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model VerificationToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model LoginHistory {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress String?
  userAgent String?
  success   Boolean  // true si réussi
  createdAt DateTime @default(now())
}



C:.
│   index.js
│
├───config
env.js
│
├───controllers
profile.controller.js
twoFactor.controller.js
user.controller.js
│
├───dto
user.dto.js
│
├───lib
async-handler.js
exceptions.js
jwt.js
logger.js
password.js
prisma.js
validate.js
│
├───middlewares
auth.middleware.js
error-handler.js
not-found.js
rateLimiter.js
validate.js
│
├───routes
2fa.routes.js
auth.routes.js
profile.routes.js
user.routes.js
│
├───schemas
profile.schema.js
user.schema.js
│
└───services
        email.service.js
        profile.service.js
        twofactor.service.js
        user.service.js




//index.js
import express from "express";
import cors from "cors";
import helmet from "helmet";
import dotenv from "dotenv";
import twoFactorRoutes from './routes/2fa.routes.js';
import cookieParser from "cookie-parser";
import session from "express-session";


dotenv.config();

import { logger, httpLogger } from "#lib/logger";
import { errorHandler } from "#middlewares/error-handler";
import { notFoundHandler } from "#middlewares/not-found";
import userRouter from "#routes/user.routes";
import authRouter from "#routes/auth.routes";
import { config } from "#config/env";
import profileRouter from "#routes/profile.routes";
const app = express();
const PORT = config.PORT || 3000;

// Middlewares
app.use(helmet());
app.use(cors());
app.use(httpLogger);
app.use(express.json());
app.use(cookieParser());

app.use(session({
    secret: config.SESSION_SECRET || "VotreSecretTrèsSécurisé",
    resave: false,
    saveUninitialized: false,
    cookie: {
        maxAge: 1000 * 60 * 60 * 24 * 7 // 7 jours
    }
}));


// Routes
app.get("/", (req, res) => {
  res.json({ success: true, message: "API Express opérationnelle" });
});

// Utilisation des routes
app.use("/users", userRouter);
app.use("/", authRouter); // Pour garder /register et /login à la racine
app.use('/2fa', twoFactorRoutes);
// Profile routes
app.use("/profile", profileRouter)

// 404 handler
app.use(notFoundHandler);

// Global error handler
app.use(errorHandler);
;



app.listen(PORT, () => {
  logger.info(`Serveur démarré sur <http://localhost>:${PORT}`);
});


//env.js
PORT=3000
NODE_ENV=development
DATABASE_URL="file:./prisma/dev.db"

# Secrets de plus de 256 caractères
JWT_SECRET="p8OO5ireFJZE5+PdSApTtkjKOO8xojdlSfUZ0KWESgjGIT6knVWyqKqDADpvg/+k+3JpBbzpVordSvU4XZBT0LISA/6o2wzRKPgQ3rSoO9bfZ7y97rA3Ornj+hnPcxUyKL/hSH7YfFvVxf/aYTBnD0Z2M4dVNYNRBZiyOIATESJ3lsrRFPzNrEzABHpZ92A5isU0pngLQtIG8QkrIJznxWGhl97UAy9iuqcsM2ni8rBGrxSdFhJO1i9qMQghsqN05PEXmXdQUhe86f4HHa2B4NGa8EJikckRMGD0vMrgLuffu1nOevy6y0B/bk6U0z/Uhk0Dv66GhZJKsc4J/WU4FY0XAatHVnrdYCS5Vuav1v0TCeWdw0p/rDNN+uaIfpMSsijanLXlZV9ocpK8xkTV7oYIxkYeNWSbefvfG3ODaIIxq2+Ptb7TqL+xZ+Q+FEGZyB8Et/1du8Zfnu/fZJVqTw=="

GITHUB_CLIENT_ID = Ov23liAbxyO0uemSBLYQ
GITHUB_CLIENT_SECRET = 6179210f3e77f9a6462425adcbc43aca76237ee8
GITHUB_STATE = "964ca29e160972aa23a91b9da8793565"



//profile.controller.js
import { ProfileService } from "#services/profile.service";
import { UserDto } from "#dto/user.dto";
export class ProfileController {
	// GET /me
	static async getMe(req, res) {
		try {
			const userId = req.user.id;
			const user = await ProfileService.getMe(userId);
			res.json({
				success: true,
				user: UserDto.transform(user),
			});
		} catch (error) {
			res.status(500).json({
				success: false,
				error: error.message,
			});
		}
	}
	// PUT /me
	static async updateMe(req, res) {
		try {
			const userId = req.user.id;
			const updatedUser = await ProfileService.updateMe(userId, req.body);
			res.json({
				success: true,
				user: UserDto.transform(updatedUser),
			});
		} catch (error) {
			res.status(error.status || 500).json({
				success: false,
				error: error.message,
			});
		}
	}
	// DELETE /me
	static async deleteMe(req, res) {
		try {
			const userId = req.user.id;
			await ProfileService.deleteMe(userId);
			res.json({
				success: true,
				message: "Compte désactivé avec succès",
			});
		} catch (error) {
			res.status(error.status || 500).json({
				success: false,
				error: error.message,
			});
		}
	}
}


//twoFactor.controller.js
import * as twoFactorService from '../services/twofactor.service.js';
import prisma from '../lib/prisma.js';

export const setup2FA = async (req, res) => {
  try {
    const userId = req.user.id;

    const user = await prisma.user.findUnique({ 
      where: { id: userId } 
    });

    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouvé" });
    }

    
    const { secret, qrCodeDataURL } = await twoFactorService.generateTwoFactorSetup(user.email);

    
    await prisma.user.update({
      where: { id: userId },
      data: { twoFactorSecret: secret }
    });

    
    return res.status(200).json({
      success: true,
      qrCode: qrCodeDataURL,
      tempSecret: secret
    });

  } catch (error) {
    console.error("Erreur détaillée :", error);
    return res.status(500).json({ 
      message: "Erreur lors de la configuration 2FA",
      error: error.message 
    });
  }
};

export const verifyAndEnable2FA = async (req, res) => {
  try {
    const { token } = req.body; 
    const userId = req.user.id; 
   
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { twoFactorSecret: true } 
    });

    if (!user || !user.twoFactorSecret) {
      return res.status(400).json({ message: "Aucune configuration 2FA trouvée pour cet utilisateur." });
    }

   
    const isValid = twoFactorService.verifyTwoFactorToken(token, user.twoFactorSecret);

    if (!isValid) {
      return res.status(400).json({ message: "Code invalide ou expiré." });
    }

    
    await prisma.user.update({
      where: { id: userId },
      data: { twoFactorEnabledAt: new Date() }
    });

    return res.status(200).json({ success: true, message: "2FA activée !" });

  } catch (error) {
    return res.status(500).json({ message: "Erreur lors de la validation." });
  }
};

export const disable2FA = async (req, res) => {
  try {
     const userId = req.user.id;

    if (!userId) {
      return res.status(400).json({ message: "ID utilisateur manquant" });
    }

   
    await prisma.user.update({
      where: { id: userId },
      data: {
        twoFactorSecret: null,
        twoFactorEnabledAt: null,
      },
    });

    return res.status(200).json({ 
      success: true, 
      message: "La double authentification a été désactivée." 
    });
  } catch (error) {
    console.error("Erreur désactivation :", error);
    return res.status(500).json({ message: "Erreur lors de la désactivation" });
  }
};

//user.controller.js
import { UserService } from "#services/user.service";
import { UserDto } from "#dto/user.dto";
//import { signToken } from "#lib/jwt";
import { validateData } from "#lib/validate";
import { registerSchema, loginSchema } from "#schemas/user.schema";
import { config } from "#config/env";
import { ForbiddenException, UnauthorizedException } from "#lib/exceptions";
import { generateAccessToken, createRefreshToken } from "#lib/jwt";


export class UserController {
  static async emialVerification(req, res) {
    const { code,email } = req.query;
    
    const user =await UserService.verifyEmail(email, code);
    return res.json({
      success:true,
      message: "Email verify successfully",
      user : user
    })
  }

  static async register(req, res) {
    const validatedData = validateData(registerSchema, req.body);
    const user = await UserService.register(validatedData)

    res.status(201).json({
      success: true,
      message: "Utilisateur créé avec succès",
      user: UserDto.transform(user),
      //token,
    });
  }

  static async login(req, res) {
    const validatedData = validateData(loginSchema, req.body);
    const { email, password } = validatedData;

    const result = await UserService.login(email, password);

    res.json({
      success: true,
      message: "Connexion réussie",
      data: {
        user: UserDto.transform(result.user),
        accessToken: result.accessToken,
        refreshToken: result.refreshToken
      }
    });
  }

  static async refresh(req, res) {
    const { refreshToken } = req.body;
    if (!refreshToken) {
      return res.status(400).json({ success: false, error: "Refresh token requis" });
    }

    const result = await UserService.refresh(refreshToken);
    res.json({
      success: true,
      accessToken: result.accessToken
    });
  }

  static async logout(req, res) {
    const { refreshToken } = req.body;
    // On récupère le token Bearer dans le header Authorization
    const authHeader = req.headers.authorization;
    const accessToken = authHeader && authHeader.split(' ')[1];

    await UserService.logout(refreshToken, accessToken);

    res.json({
      success: true,
      message: "Déconnexion réussie"
    });
  }

  // github authentication
  static async githubAuth(_req, res) {
    const githubClientId = config.GITHUB_CLIENT_ID;
    const githubRedirectURL = 'http://localhost:3000/auth/githubCallback';
    const state = config.GITHUB_STATE;
    const url = `https://github.com/login/oauth/authorize?client_id=${githubClientId}&redirect_uri=${githubRedirectURL}&scope=user&state=${state}`;
    res.redirect(url);
  }

  static async githubCallback(req, res) {
    const { code, state } = req.query;
    if (state !== config.GITHUB_STATE) {
      console.error(`State Mismatch. Received: ${state}, Expected: ${config.GITHUB_STATE}`);
      throw new UnauthorizedException("state doesn't match possible cssrf");
    }
    const githubClientId = config.GITHUB_CLIENT_ID;
    const githubClientSecret = config.GITHUB_CLIENT_SECRET;
    const githubRedirectURL = 'http://localhost:3000/auth/githubCallback';

    let response = await fetch('https://github.com/login/oauth/access_token', {
      method: "POST",
      headers: {
        'content-type': 'application/json',
        'accept': 'application/json'
      },
      body: JSON.stringify({
        client_id: githubClientId,
        client_secret: githubClientSecret,
        code: code,
        redirect_uri: githubRedirectURL
      })
    })

    if (!response.ok) {
      throw new ForbiddenException("unprocessable access_token ");
    }

    let data = await response.json();

    const access_token = data.access_token;

    response = await fetch('https://api.github.com/user', {
      method: "GET",
      headers: {
        'content-type': 'application/json',
        'accept': 'application/json',
        'Authorization': `Bearer ${access_token}`,
        'User-Agent': 'NodeJS-App'
      }
    })

    if (!response.ok) {
      throw new ForbiddenException("impossible to get user data");
    }
    const userData = await response.json();
    let user = await UserService.findByEmail(userData.email);

    if (user) {
      const result = await UserService.loginGithubUser(user);
      return res.json({
        success: true,
        message: "Connexion réussie",
        data: {
          user: UserDto.transform(result.user),
          accessToken: result.accessToken,
          refreshToken: result.refreshToken
        }
      })
    } else {
      const user = await UserService.registerGithubUser(userData);

      return res.status(201).json({
        success: true,
        message: "Utilisateur créé avec succès",
        user: UserDto.transform(user),
      });
    }

  }

  static async refresh(req, res) {
    const { refreshToken } = req.body;
    if (!refreshToken) {
      return res.status(400).json({ success: false, error: "Refresh token requis" });
    }

    const result = await UserService.refresh(refreshToken);
    res.json({
      success: true,
      accessToken: result.accessToken
    });
  }

  static async logout(req, res) {
    const { refreshToken } = req.body;
    // On récupère le token Bearer dans le header Authorization
    const authHeader = req.headers.authorization;
    const accessToken = authHeader && authHeader.split(' ')[1];

    await UserService.logout(refreshToken, accessToken);

    res.json({
      success: true,
      message: "Déconnexion réussie"
    });
  }
  static async getAll(req, res) {
    const users = await UserService.findAll();
    res.json({
      success: true,
      users: UserDto.transform(users),
    });
  }

  static async getById(req, res) {
    const user = await UserService.findById(parseInt(req.params.id));
    res.json({
      success: true,
      user: UserDto.transform(user),
    });
  }
  static async forgotPassword(req, res) {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ success: false, error: "Email requis" });
    }

    await UserService.forgotPassword(email);
    res.json({
      success: true,
      message: "Si cet email existe, un lien de récupération a été envoyé."
    });
  }

  static async resetPassword(req, res) {
    const { token, password } = req.body;
    if (!token || !password) {
      throw new BadRequestException("Token et mot de passe requis");
    }

    await UserService.resetPassword(token, password);
    res.json({ success: true, message: "Mot de passe modifié avec succès." });
  }


  static async changePassword(req, res) {
    const { oldPassword, newPassword } = req.body;

    await UserService.changePassword(req.user.id, oldPassword, newPassword);

    res.json({ success: true, message: "Mot de passe mis à jour" });
  }
}




//user.dto.js
export class UserDto {
  constructor(user) {
    this.id = user.id;
    this.email = user.email;
    this.firstName = user.firstName;
    this.lastName = user.lastName;
    this.createdAt = user.createdAt;
  }

  // Cette méthode permet de transformer soit un utilisateur, soit une liste d'utilisateurs
  static transform(data) {
    if (Array.isArray(data)) {
      return data.map((user) => new UserDto(user));
    }
    return new UserDto(data);
  }
}



//async-handler.js
export function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}


//exceptions.js
export class HttpException extends Error {
  constructor(statusCode, message, details = null) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
    this.name = this.constructor.name;
  }
}

export class BadRequestException extends HttpException {
  constructor(message = "Bad Request", details = null) {
    super(400, message, details);
  }
}

export class UnauthorizedException extends HttpException {
  constructor(message = "Unauthorized") {
    super(401, message);
  }
}

export class ForbiddenException extends HttpException {
  constructor(message = "Forbidden") {
    super(403, message);
  }
}

export class NotFoundException extends HttpException {
  constructor(message = "Not Found") {
    super(404, message);
  }
}

export class ConflictException extends HttpException {
  constructor(message = "Conflict") {
    super(409, message);
  }
}

export class ValidationException extends HttpException {
  constructor(errors) {
    super(400, "Validation Failed", errors);
  }
}


//jwt.js
import crypto, { randomBytes } from 'node:crypto'; 
import { SignJWT, jwtVerify } from "jose";
import prisma from "#lib/prisma";
import { config } from '#config/env';

const secret = new TextEncoder().encode(config.JWT_SECRET);
const alg = "HS256";


export async function generateAccessToken(payload) {
  return new SignJWT({payload, padding: generatePadding()})
    .setProtectedHeader({ alg })
    .setIssuedAt()
    .setExpirationTime("15m")
    .sign(secret);
}

function generatePadding(){
  return randomBytes(510).toString('hex');
}

// Crée un Refresh Token en base de données (valide 7 jours)
export async function createRefreshToken(userId) {
  const token = crypto.randomBytes(512).toString("hex");
  
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 7);

  await prisma.refreshToken.create({
    data: {
      token,
      userId,
      expiresAt,
    },
  });

  return token;
}

// Vérifie la validité d'un Access Token
export async function verifyAccessToken(token) {
  const { payload } = await jwtVerify(token, secret);
  return payload.payload;
}

export async function verifyRefreshToken(token) {
  const storedToken = await prisma.refreshToken.findUnique({
    where: { token },
    include: { user: true }
  });

  if (!storedToken) return null;

  // Vérifier s'il est expiré ou révoqué
  const isExpired = new Date() > storedToken.expiresAt;
  const isRevoked = storedToken.revokedAt !== null;

  if (isExpired || isRevoked) return null;

  return storedToken;
}



export async function verifyToken(token) {
  const { payload } = await jwtVerify(token, secret);
  return payload;
}


//logger.js
import pino from "pino";
import pinoHttp from "pino-http";

const isProduction = process.env.NODE_ENV === "production";

export const logger = pino({
  level: isProduction ? "info" : "debug",
  transport: isProduction
    ? undefined
    : {
        target: "pino-pretty",
        options: { colorize: true },
      },
});

export const httpLogger = pinoHttp({ logger });


//password.js
import argon2 from "argon2";

export async function hashPassword(password) {
  return argon2.hash(password);
}

export async function verifyPassword(hash, password) {
  return argon2.verify(hash, password);
}

//prisma.js
import "dotenv/config";
import { PrismaBetterSqlite3 } from "@prisma/adapter-better-sqlite3";
import { PrismaClient } from "@prisma/client";

const connectionString = process.env.DATABASE_URL;

const adapter = new PrismaBetterSqlite3({ url: connectionString });
const prisma = new PrismaClient({ adapter });

export default prisma;


//validate.js
import { ValidationException } from "#lib/exceptions";

/**
 * Cette fonction vérifie que les données reçues respectent les règles prévues.
 * Si ce n'est pas le cas, elle lève une erreur (Exception) que le serveur catchera.
 */
export function validateData(schema, data) {
  const result = schema.safeParse(data);

  if (!result.success) {
    throw new ValidationException(result.error.flatten().fieldErrors);
  }

  return result.data;
}



//auth.middleware.js
import { verifyToken } from "#lib/jwt";
import { verifyAccessToken } from "#lib/jwt";
import prisma from "#lib/prisma";
import { UnauthorizedException } from "#lib/exceptions";

export const auth = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
      throw new UnauthorizedException("Token manquant");
    }

    // On vérifie si le token est dans la blacklist (déconnexion)
    const isBlacklisted = await prisma.blacklistedAccessToken.findUnique({
      where: { token }
    });
    if (isBlacklisted) throw new UnauthorizedException("Token révoqué");
    const payload = await verifyAccessToken(token);
    
// Récupère l'utilisateur
    const user = await prisma.user.findUnique({ where: { id: payload.id } });
    if (!user || user.disabledAt) throw new UnauthorizedException("Utilisateur invalide");

    req.user = { id: user.id, email: user.email, name: user.firstName + " " + user.lastName };
    next();
    //req.user = { id: payload.id };
    
    //next();
  } catch (error) {
    next(new UnauthorizedException("Token invalide"));
  }
};

//error-handler.js
import { HttpException } from "#lib/exceptions";
import { logger } from "#lib/logger";

export function errorHandler(err, req, res, next) {
  if (err instanceof HttpException) {
    logger.warn({ err, path: req.path }, err.message);
  } else {
    logger.error({ err, path: req.path }, "Unhandled error");
  }

  if (err instanceof HttpException) {
    return res.status(err.statusCode).json({
      success: false,
      error: err.message,
      ...(err.details && { details: err.details }),
    });
  }

  if (err.code === "P2002") {
    return res.status(409).json({
      success: false,
      error: "Resource already exists",
    });
  }

  if (err.code === "P2025") {
    return res.status(404).json({
      success: false,
      error: "Resource not found",
    });
  }

  if (err instanceof SyntaxError && err.status === 400) {
    return res.status(400).json({
      success: false,
      error: "Invalid JSON",
    });
  }

  const isProduction = process.env.NODE_ENV === "production";

  res.status(500).json({
    success: false,
    error: isProduction ? "Internal Server Error" : err.message,
    ...(!isProduction && { stack: err.stack }),
  });
}


//not-found.js
import { NotFoundException } from "#lib/exceptions";

export function notFoundHandler(req, res, next) {
  throw new NotFoundException(`Route ${req.method} ${req.path} not found`);
}


//rateLimiter.js
import { rateLimit } from "express-rate-limit";

export const loginLimiter = rateLimit({
	windowMs: 15 * 60 * 1000, // 15 minutes
	max:5, // 5 tentatives par IP
	message: {
		success: false,
		error: "Trop de tentatives de connexion,réessayez après 15 minutes"
	},
	standardHeaders: true,// ajoute les en-têtes RateLimit dans la réponse
	legacyHeaders: false,
});

//validate.js
import { ValidationException } from "../lib/exceptions.js";

export function validate(schema) {
    return (req, res, next) => {
        const result = schema.safeParse(req.body);

        if (!result.success) {
            throw new ValidationException(result.error.flatten().fieldErrors);
        }

        req.body = result.data;
        next();
    };
}


//2fa.routes.js
import { Router } from 'express';
import * as twoFactorController from '../controllers/twoFactor.controller.js';
import { auth } from '../middlewares/auth.middleware.js'; 
const router = Router();


router.post('/setup',auth, twoFactorController.setup2FA);
router.post('/disable',auth, twoFactorController.disable2FA);
router.post('/verifyAndEnable',auth,  twoFactorController.verifyAndEnable2FA);

export default router;

//auth.routes.js
import { Router } from "express";
import { UserController } from "#controllers/user.controller";
import { asyncHandler } from "#lib/async-handler";
import { loginLimiter } from "#middlewares/rateLimiter";

const router = Router();

// Inscription et Connexion
router.post("/register", asyncHandler(UserController.register));
router.post("/login", loginLimiter, asyncHandler(UserController.login));

router.get("/auth/emailVerification", asyncHandler(UserController.emialVerification));

router.post("/refresh", asyncHandler(UserController.refresh));
router.post("/logout", asyncHandler(UserController.logout));

// src/routes/auth.routes.js
router.post("/forgot_password", asyncHandler(UserController.forgotPassword));
router.post("/reset_password", asyncHandler(UserController.resetPassword));

// authentification via github
router.get("/auth/github", asyncHandler(UserController.githubAuth));
router.get("/auth/githubCallback", asyncHandler(UserController.githubCallback));

export default router;


//profile.routes.js
import { Router} from "express";
import { ProfileController } from "#controllers/profile.controller";
import {validate} from "#middlewares/validate";
import { updateProfileSchema } from "#schemas/profile.schema";
import { auth } from "#middlewares/auth.middleware";
import { asyncHandler } from "#lib/async-handler";

const router = Router();

// GET /me
router.get("/me", auth, asyncHandler(ProfileController.getMe));

// PUT /me
router.put("/me", auth, validate(updateProfileSchema), asyncHandler(ProfileController.updateMe));

// DELETE /me
router.delete("/me", auth, asyncHandler(ProfileController.deleteMe));
export default router;

//user.routes.js
import { Router } from "express";
import { UserController } from "#controllers/user.controller";
import { asyncHandler } from "#lib/async-handler";
import { auth } from "#middlewares/auth.middleware";

const router = Router();

// Consultation de la liste ou d'un utilisateur
router.get("/",auth, asyncHandler(UserController.getAll));
router.get("/:id",auth , asyncHandler(UserController.getById));

router.post("/change-password", auth, asyncHandler(UserController.changePassword));
export default router;


//profile.schema.js
import {z} from "zod";
/**
 * Schema de validation pour la mise à jour du profil utilisateur
 * Tous les champs sont optionnels
 */
export const updateProfileSchema = z.object({
		name: z
		.string()
		.min(2, "Le nom doit contenir au moins 2 caractères")
		.optional(),

		email:z
		.string()
		.email("Email invalide")
		.optional(),
});

//user.schema.js
import { z } from "zod";

export const registerSchema = z.object({
  email: z.string().email("Format d'email invalide"),
  password: z.string()
    .min(8, "Le mot de passe doit contenir au moins 8 caractères")
    .regex(/[A-Z]/, "Doit contenir une majuscule")
    .regex(/[0-9]/, "Doit contenir un chiffre"),
  firstName: z.string().min(2, "Prénom trop court").optional(),
  lastName: z.string().min(2, "Nom trop court").optional(),
  email: z.email("Email invalide"),
  password: z.string().min(8, "Minimum 8 caractères"),
  name: z.string().min(2).optional(),
});

export const loginSchema = z.object({
  email: z.email("Email invalide"),
  password: z.string().min(1, "Mot de passe requis"),
});




//email.service.js
import { NotFoundException } from "#lib/exceptions";
import nodemailer from "nodemailer";

export class EmailService {

    static async sendEmail(email, emailSubject, emailContent) {
        const transporter = nodemailer.createTransport({
            port: 1025,
            secure: false
        });

        const mailOptions = {
            from: 'apiauth@email.com',
            to: email,
            subject: emailSubject != null ? emailSubject : "",
            html: `<p> ${emailContent}  </p>`
        }

        // send email
        transporter.sendMail(mailOptions, function(error, info){
            if (error) {
                throw new NotFoundException(error)
            }
        })
    }
}

//profile.service.js
import prisma from "#lib/prisma"; // ton client Prisma
import { NotFoundException } from "#lib/exceptions";

export class ProfileService {
  /** Récupère les informations du profil */
  static async getMe(userId) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        createdAt: true,
        disabledAt: true,
      },
    });

    if (!user || user.disabledAt) {
      throw new NotFoundException("Utilisateur introuvable");
    }

    return user;
  }

  /** Met à jour le profil */
  static async updateMe(userId, data) {
    // Vérifier que l'utilisateur existe
    const existingUser = await prisma.user.findUnique({ where: { id: userId } });
    if (!existingUser || existingUser.disabledAt) {
      throw new NotFoundException("Utilisateur introuvable");
    }

    // Mise à jour
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        email: data.email,
        firstName: data.firstName,
        lastName: data.lastName,
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        createdAt: true,
      },
    });

    return updatedUser;
  }

  /** Désactive le compte (soft delete) */
  static async deleteMe(userId) {
    const existingUser = await prisma.user.findUnique({ where: { id: userId } });
    if (!existingUser || existingUser.disabledAt) {
      throw new NotFoundException("Utilisateur introuvable");
    }

    await prisma.user.update({
      where: { id: userId },
      data: { disabledAt: new Date() },
    });

    return { success: true, message: "Compte désactivé avec succès" };
  }
}


//twofactor.service.js
import { authenticator } from 'otplib';
import QRCode from 'qrcode';
//Génération et transformation du lien du code secret en qr code
export const generateTwoFactorSetup = async (userEmail) => {
  const secret = authenticator.generateSecret();
  
  const otpauth = authenticator.keyuri(userEmail, 'twofactorApp', secret);
  
  const qrCodeDataURL = await QRCode.toDataURL(otpauth);

  return { secret, qrCodeDataURL };
};
//vérification si le code a 6 chiffre entré par l'utilisater 
export const verifyTwoFactorToken = (token, secret) => {
  return authenticator.verify({
    token,  
    secret,
    window: 2   
  });
};


//user.service.js
import prisma from "#lib/prisma";
import { generateAccessToken, createRefreshToken, verifyRefreshToken } from "#lib/jwt";
import { hashPassword, verifyPassword } from "#lib/password";
import { ConflictException, UnauthorizedException, NotFoundException } from "#lib/exceptions";
import { UserDto } from "#dto/user.dto";
import crypto from 'node:crypto';
import { EmailService } from "#services/email.service";

export class UserService {
    static async verifyEmail(email, code) {
        const user = await this.findByEmail(email)

        if (!user || user.emailVerifyToken != code) {
            console.error("code: ", code, "verifCode: ", user.emailVerifyToken);

            throw new UnauthorizedException("Utilisateur non authentifié ou code invalide")
        }

        return await prisma.user.update({
            where: { email },
            data: {
                emailVerifiedAt: new Date(),
                emailVerifyToken: null
            }
        })
    }
    // Inscription 
    static async register(data) {
        const { email, password, firstName, lastName } = data;

        const existingUser = await prisma.user.findUnique({ where: { email } });
        if (existingUser) {
            throw new ConflictException("Email déjà utilisé");
        }

        const hashedPassword = await hashPassword(password);

        const emailVerifyToken = crypto.randomBytes(512).toString("hex");
        const expiresAt = new Date(Date.now() + 900000); // 15min

        // envoyer un mail pour vérifer le mail 
        const url = `http://localhost:3000/auth/emailVerification?code=${emailVerifyToken}&email=${email}`;
        await EmailService.sendEmail(email, "Email Verification", `<a href=${url}>Cliquer sur ce lien pour vérifier votre email</a>`);
        // on cree l'utilisateur sans  vérifier l'email
        return await prisma.user.create({
            data: {
                email,
                password: hashedPassword,
                firstName,
                lastName,
                emailVerifyToken,
                expiresAt
            },
        })
    }

    // Connexion
    static async login(email, password) {
        const user = await prisma.user.findUnique({ where: { email } });

        if (!user || !(await verifyPassword(user.password, password))) {
            throw new UnauthorizedException("Identifiants invalides");
        }

        const accessToken = await generateAccessToken({
            id: user.id,
            email: user.email
        });

        const refreshToken = await createRefreshToken(user.id);

        return {
            user: new UserDto(user),
            accessToken,
            refreshToken
        };
    }

    // 3. Inscription via GitHub (OAuth)
    static async registerGithubUser(userData) {
        const { email, name, id } = userData;
        const nameParts = name.split(' ');
        const lastName = nameParts[0];
        const firstName = nameParts.slice(1).join(' ') || '';

        return prisma.user.create({
            data: {
                email: email,
                lastName: lastName,
                firstName: firstName,
                oauthAccounts: {
                    create: {
                        provider: 'GitHub',
                        providerId: String(id),
                    }
                }
            }
        });
    }

    // 4. Connexion via GitHub
    static async loginGithubUser(user) {
        const accessToken = await generateAccessToken({
            id: user.id,
            email: user.email
        });

        const refreshToken = await createRefreshToken(user.id);

        return {
            user: new UserDto(user),
            accessToken,
            refreshToken
        };
    }

    static async registerGithubUser(userData) {
        const { email, name, id } = userData;
        const lastName = name.split(' ')[0];
        const firstName = name.split(' ')[1];

        return prisma.user.create({
            data: {
                email: email,
                lastName: lastName,
                firstName: firstName,
                oauthAccounts: {
                    create: {
                        provider: 'GitHub',
                        providerId: String(id),
                    }
                }
            }
        })
    }

    static async saveLoginHistory(userId, data) {
        return prisma.loginHistory.create({
            data: {
                userId,
                ip: data.ip,
                userAgent: data.userAgent,
            },
        });
    }

    // 5. Utilitaires de recherche
    static async findAll() {
        return prisma.user.findMany();
    }

    static async findById(id) {
        const user = await prisma.user.findUnique({ where: { id } });
        if (!user) throw new NotFoundException("Utilisateur non trouvé");
        return user;
    }

    static async findByEmail(email) {
        return await prisma.user.findUnique({ where: { email } });
    }

    // 6. Gestion des Tokens (Refresh & Logout)
    static async refresh(token) {
        const storedToken = await verifyRefreshToken(token);
        if (!storedToken) {
            throw new UnauthorizedException("Refresh Token invalide ou expiré");
        }

        const accessToken = await generateAccessToken({
            id: storedToken.user.id,
            email: storedToken.user.email
        });
        const newRefreshToken = await prisma.$transaction(async (tx) => {
            // Invalider l'ancien jeton
            await tx.refreshToken.update({
                where: { token: token },
                data: { revokedAt: new Date() }
            });

            // Générer une nouvelle chaîne de 1024 caractères pour le nouveau jeton
            const tokenString = crypto.randomBytes(512).toString("hex");
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + 7); // Valide 7 jours

            // Créer le nouveau jeton en base
            const created = await tx.refreshToken.create({
                data: {
                    token: tokenString,
                    userId: storedToken.user.id,
                    expiresAt,
                },
            });

            return created.token;
        });

        // 4. On renvoie les DEUX nouveaux jetons
        return {
            accessToken,
            refreshToken: newRefreshToken
        };
    }

    static async logout(refreshToken, accessToken) {
        // Invalider le refresh token
        await prisma.refreshToken.updateMany({
            where: { token: refreshToken },
            data: { revokedAt: new Date() }
        });

        // Blacklister l'access token
        if (accessToken) {
            await prisma.blacklistedAccessToken.create({
                data: {
                    token: accessToken,
                    expiresAt: new Date(Date.now() + 15 * 60 * 1000)
                }
            });
        }
    }

    // 7. Mot de passe oublié
    static async forgotPassword(email) {
        const user = await prisma.user.findUnique({ where: { email } });
        if (!user) return;

        const token = crypto.randomBytes(512).toString("hex");
        const expiresAt = new Date(Date.now() + 3600000); // 1h

        await prisma.passwordResetToken.create({
            data: {
                token,
                userId: user.id,
                expiresAt
            }
        });

        const url = `http://localhost:3000/auth/emailVerification?code=${emailVerifyToken}&email=${email}`;
        await EmailService.sendEmail(email, "Email Verification", `<a href=${url}>Cliquer sur ce lien pour vérifier votre email</a>`);
        console.log(`--- SIMULATION EMAIL ---`);
        console.log(`Lien: http://localhost:3000/reset_password?token=${token}`);
        console.log(`-------------------------`);
    }

    static async resetPassword(token, newPassword) {
        const resetToken = await prisma.passwordResetToken.findUnique({
            where: { token },
            include: { user: true }
        });

        if (!resetToken || resetToken.expiresAt < new Date()) {
            throw new UnauthorizedException("Token invalide ou expiré");
        }

        const hashedPassword = await hashPassword(newPassword);

        await prisma.$transaction([
            prisma.user.update({
                where: { id: resetToken.userId },
                data: { password: hashedPassword }
            }),
            prisma.passwordResetToken.delete({
                where: { token }
            })
        ]);
    }

    // 8. Changement de mot de passe (Profil)
    static async changePassword(userId, oldPassword, newPassword) {
        const user = await prisma.user.findUnique({ where: { id: userId } });
        if (!user) throw new NotFoundException("Utilisateur non trouvé");

        const isValid = await verifyPassword(user.password, oldPassword);
        if (!isValid) throw new UnauthorizedException("L'ancien mot de passe est incorrect");

        const hashedPassword = await hashPassword(newPassword);

        await prisma.user.update({
            where: { id: userId },
            data: { password: hashedPassword }
        });
    }

    // 9. Historique
    static async saveLoginHistory(userId, data) {
        return prisma.loginHistory.create({
            data: {
                userId,
                ip: data.ip,
                userAgent: data.userAgent,
            },
        });
    }
}






/* TESTS*/
1. Authentification & Inscription
Inscription (POST)

URL : http://localhost:3000/register 

Body (JSON) :

JSON

{
  "email": "test@example.com",
  "password": "Password123",
  "firstName": "John",
  "lastName": "Doe"
}

Note : Le mot de passe doit contenir une majuscule et un chiffre selon votre schéma.

Connexion (POST)

URL : http://localhost:3000/login 

Body (JSON) :

JSON

{
  "email": "test@example.com",
  "password": "Password123"
}

Action : Copiez l' accessToken reçu dans la réponse pour les tests suivants.


2. Gestion du Profil (Requiert Auth)

Pour ces requêtes, allez dans l'onglet Auth de Yaak, choisissez Bearer Token et collez votre jeton. 


Voir mon profil (GET)

URL : http://localhost:3000/profile/me 

Modifier mon profil (PUT)

URL : http://localhost:3000/profile/me 

Body (JSON) :

JSON

{
  "firstName": "Jane",
  "lastName": "Smith"
}
3. Double Authentification (2FA)
Initialiser le 2FA (POST)

URL : http://localhost:3000/2fa/setup 


Réponse : Vous recevrez un qrCode (base64) et un tempSecret.


Activer le 2FA (POST)

URL : http://localhost:3000/2fa/verifyAndEnable 

Body (JSON) :

JSON

{
  "token": "123456" 
}
(Remplacez par le code de votre application Google Authenticator/Authy).

4. Maintenance des Tokens
Rafraîchir le Token (POST)

URL : http://localhost:3000/refresh 

Body (JSON) :

JSON

{
  "refreshToken": "VOTRE_REFRESH_TOKEN_ICI"
}
Déconnexion (POST)

URL : http://localhost:3000/logout 


Headers : Authorization: Bearer <accessToken> 

Body (JSON) :

JSON

{
  "refreshToken": "VOTRE_REFRESH_TOKEN_ICI"
}

5. Pour tester la fonctionnalité de changement de mot de passe (quand l'utilisateur est déjà connecté et souhaite modifier son mot de passe actuel), voici la configuration à utiliser dans Yaak :

Configuration du test dans Yaak
Méthode : POST


URL : http://localhost:3000/users/change-password 


Auth (Onglet) : Sélectionner Bearer Token et coller l' accessToken obtenu lors de la connexion. 



Body (JSON) :

JSON

{
  "oldPassword": "AncienMotDePasse123",
  "newPassword": "NouveauMotDePasse456"
}